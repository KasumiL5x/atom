// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lights/LightChanged.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Atom.Proto.Lights {

  /// <summary>Holder for reflection information generated from lights/LightChanged.proto</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class LightChangedReflection {

    #region Descriptor
    /// <summary>File descriptor for lights/LightChanged.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LightChangedReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChlsaWdodHMvTGlnaHRDaGFuZ2VkLnByb3RvEhFhdG9tLnByb3RvLmxpZ2h0",
            "cxoWbGlnaHRzL0xpZ2h0VHlwZS5wcm90bxoNVmVjdG9yMy5wcm90bxoLQ29s",
            "b3IucHJvdG8iqAMKDExpZ2h0Q2hhbmdlZBIRCglMaWdodE5hbWUYASABKAkS",
            "LAoEVHlwZRgCIAEoDjIcLmF0b20ucHJvdG8ubGlnaHRzLkxpZ2h0VHlwZUgA",
            "EicKCFBvc2l0aW9uGAMgASgLMhMuYXRvbS5wcm90by5WZWN0b3IzSAASKAoJ",
            "RGlyZWN0aW9uGAQgASgLMhMuYXRvbS5wcm90by5WZWN0b3IzSAASDwoFUmFu",
            "Z2UYBSABKAJIABIiCgVDb2xvchgGIAEoCzIRLmF0b20ucHJvdG8uQ29sb3JI",
            "ABITCglJbnRlbnNpdHkYByABKAJIABITCglDb25lQW5nbGUYCCABKAJIABIX",
            "Cg1QZW51bWJyYUFuZ2xlGAkgASgCSAASEQoHRHJvcG9mZhgKIAEoAkgAEhEK",
            "B1NoYWRvd3MYCyABKAhIABIaChBTaGFkb3dSZXNvbHV0aW9uGAwgASgFSAAS",
            "FAoKU2hhZG93QmlhcxgNIAEoAkgAEigKC1NoYWRvd0NvbG9yGA4gASgLMhEu",
            "YXRvbS5wcm90by5Db2xvckgAQgoKCFByb3BlcnR5YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Atom.Proto.Lights.LightTypeReflection.Descriptor, global::Atom.Proto.Vector3Reflection.Descriptor, global::Atom.Proto.ColorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Atom.Proto.Lights.LightChanged), global::Atom.Proto.Lights.LightChanged.Parser, new[]{ "LightName", "Type", "Position", "Direction", "Range", "Color", "Intensity", "ConeAngle", "PenumbraAngle", "Dropoff", "Shadows", "ShadowResolution", "ShadowBias", "ShadowColor" }, new[]{ "Property" }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class LightChanged : pb::IMessage<LightChanged> {
    private static readonly pb::MessageParser<LightChanged> _parser = new pb::MessageParser<LightChanged>(() => new LightChanged());
    public static pb::MessageParser<LightChanged> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::Atom.Proto.Lights.LightChangedReflection.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public LightChanged() {
      OnConstruction();
    }

    partial void OnConstruction();

    public LightChanged(LightChanged other) : this() {
      lightName_ = other.lightName_;
      switch (other.PropertyCase) {
        case PropertyOneofCase.Type:
          Type = other.Type;
          break;
        case PropertyOneofCase.Position:
          Position = other.Position.Clone();
          break;
        case PropertyOneofCase.Direction:
          Direction = other.Direction.Clone();
          break;
        case PropertyOneofCase.Range:
          Range = other.Range;
          break;
        case PropertyOneofCase.Color:
          Color = other.Color.Clone();
          break;
        case PropertyOneofCase.Intensity:
          Intensity = other.Intensity;
          break;
        case PropertyOneofCase.ConeAngle:
          ConeAngle = other.ConeAngle;
          break;
        case PropertyOneofCase.PenumbraAngle:
          PenumbraAngle = other.PenumbraAngle;
          break;
        case PropertyOneofCase.Dropoff:
          Dropoff = other.Dropoff;
          break;
        case PropertyOneofCase.Shadows:
          Shadows = other.Shadows;
          break;
        case PropertyOneofCase.ShadowResolution:
          ShadowResolution = other.ShadowResolution;
          break;
        case PropertyOneofCase.ShadowBias:
          ShadowBias = other.ShadowBias;
          break;
        case PropertyOneofCase.ShadowColor:
          ShadowColor = other.ShadowColor.Clone();
          break;
      }

    }

    public LightChanged Clone() {
      return new LightChanged(this);
    }

    /// <summary>Field number for the "LightName" field.</summary>
    public const int LightNameFieldNumber = 1;
    private string lightName_ = "";
    /// <summary>
    /// *&lt; Name of the light that changed. 
    /// </summary>
    public string LightName {
      get { return lightName_; }
      set {
        lightName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "Type" field.</summary>
    public const int TypeFieldNumber = 2;
    /// <summary>
    /// *&lt; Type of light source. 
    /// </summary>
    public global::Atom.Proto.Lights.LightType Type {
      get { return propertyCase_ == PropertyOneofCase.Type ? (global::Atom.Proto.Lights.LightType) property_ : global::Atom.Proto.Lights.LightType.kLightTypeAmbient; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.Type;
      }
    }

    /// <summary>Field number for the "Position" field.</summary>
    public const int PositionFieldNumber = 3;
    /// <summary>
    /// *&lt; World-space position (point, spot). 
    /// </summary>
    public global::Atom.Proto.Vector3 Position {
      get { return propertyCase_ == PropertyOneofCase.Position ? (global::Atom.Proto.Vector3) property_ : null; }
      set {
        property_ = value;
        propertyCase_ = value == null ? PropertyOneofCase.None : PropertyOneofCase.Position;
      }
    }

    /// <summary>Field number for the "Direction" field.</summary>
    public const int DirectionFieldNumber = 4;
    /// <summary>
    /// *&lt; World-space direction (directional, spot). 
    /// </summary>
    public global::Atom.Proto.Vector3 Direction {
      get { return propertyCase_ == PropertyOneofCase.Direction ? (global::Atom.Proto.Vector3) property_ : null; }
      set {
        property_ = value;
        propertyCase_ = value == null ? PropertyOneofCase.None : PropertyOneofCase.Direction;
      }
    }

    /// <summary>Field number for the "Range" field.</summary>
    public const int RangeFieldNumber = 5;
    /// <summary>
    /// *&lt; Light range (point, spot). 
    /// </summary>
    public float Range {
      get { return propertyCase_ == PropertyOneofCase.Range ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.Range;
      }
    }

    /// <summary>Field number for the "Color" field.</summary>
    public const int ColorFieldNumber = 6;
    /// <summary>
    /// *&lt; Light color. 
    /// </summary>
    public global::Atom.Proto.Color Color {
      get { return propertyCase_ == PropertyOneofCase.Color ? (global::Atom.Proto.Color) property_ : null; }
      set {
        property_ = value;
        propertyCase_ = value == null ? PropertyOneofCase.None : PropertyOneofCase.Color;
      }
    }

    /// <summary>Field number for the "Intensity" field.</summary>
    public const int IntensityFieldNumber = 7;
    /// <summary>
    /// *&lt; Light intensity. 
    /// </summary>
    public float Intensity {
      get { return propertyCase_ == PropertyOneofCase.Intensity ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.Intensity;
      }
    }

    /// <summary>Field number for the "ConeAngle" field.</summary>
    public const int ConeAngleFieldNumber = 8;
    /// <summary>
    /// *&lt; Interior cone angle in degrees (spot). 
    /// </summary>
    public float ConeAngle {
      get { return propertyCase_ == PropertyOneofCase.ConeAngle ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.ConeAngle;
      }
    }

    /// <summary>Field number for the "PenumbraAngle" field.</summary>
    public const int PenumbraAngleFieldNumber = 9;
    /// <summary>
    /// *&lt; Penumbra angle in degrees (spot). 
    /// </summary>
    public float PenumbraAngle {
      get { return propertyCase_ == PropertyOneofCase.PenumbraAngle ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.PenumbraAngle;
      }
    }

    /// <summary>Field number for the "Dropoff" field.</summary>
    public const int DropoffFieldNumber = 10;
    /// <summary>
    /// *&lt; Light dropoff (spot). 
    /// </summary>
    public float Dropoff {
      get { return propertyCase_ == PropertyOneofCase.Dropoff ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.Dropoff;
      }
    }

    /// <summary>Field number for the "Shadows" field.</summary>
    public const int ShadowsFieldNumber = 11;
    /// <summary>
    /// *&lt; Whether shadows are enabled. 
    /// </summary>
    public bool Shadows {
      get { return propertyCase_ == PropertyOneofCase.Shadows ? (bool) property_ : false; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.Shadows;
      }
    }

    /// <summary>Field number for the "ShadowResolution" field.</summary>
    public const int ShadowResolutionFieldNumber = 12;
    /// <summary>
    /// *&lt; Shadow resolution. 
    /// </summary>
    public int ShadowResolution {
      get { return propertyCase_ == PropertyOneofCase.ShadowResolution ? (int) property_ : 0; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.ShadowResolution;
      }
    }

    /// <summary>Field number for the "ShadowBias" field.</summary>
    public const int ShadowBiasFieldNumber = 13;
    /// <summary>
    /// *&lt; Shadow bias. 
    /// </summary>
    public float ShadowBias {
      get { return propertyCase_ == PropertyOneofCase.ShadowBias ? (float) property_ : 0F; }
      set {
        property_ = value;
        propertyCase_ = PropertyOneofCase.ShadowBias;
      }
    }

    /// <summary>Field number for the "ShadowColor" field.</summary>
    public const int ShadowColorFieldNumber = 14;
    /// <summary>
    /// *&lt; Shadow color. 
    /// </summary>
    public global::Atom.Proto.Color ShadowColor {
      get { return propertyCase_ == PropertyOneofCase.ShadowColor ? (global::Atom.Proto.Color) property_ : null; }
      set {
        property_ = value;
        propertyCase_ = value == null ? PropertyOneofCase.None : PropertyOneofCase.ShadowColor;
      }
    }

    private object property_;
    /// <summary>Enum of possible cases for the "Property" oneof.</summary>
    public enum PropertyOneofCase {
      None = 0,
      Type = 2,
      Position = 3,
      Direction = 4,
      Range = 5,
      Color = 6,
      Intensity = 7,
      ConeAngle = 8,
      PenumbraAngle = 9,
      Dropoff = 10,
      Shadows = 11,
      ShadowResolution = 12,
      ShadowBias = 13,
      ShadowColor = 14,
    }
    private PropertyOneofCase propertyCase_ = PropertyOneofCase.None;
    public PropertyOneofCase PropertyCase {
      get { return propertyCase_; }
    }

    public void ClearProperty() {
      propertyCase_ = PropertyOneofCase.None;
      property_ = null;
    }

    public override bool Equals(object other) {
      return Equals(other as LightChanged);
    }

    public bool Equals(LightChanged other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (LightName != other.LightName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(Position, other.Position)) return false;
      if (!object.Equals(Direction, other.Direction)) return false;
      if (Range != other.Range) return false;
      if (!object.Equals(Color, other.Color)) return false;
      if (Intensity != other.Intensity) return false;
      if (ConeAngle != other.ConeAngle) return false;
      if (PenumbraAngle != other.PenumbraAngle) return false;
      if (Dropoff != other.Dropoff) return false;
      if (Shadows != other.Shadows) return false;
      if (ShadowResolution != other.ShadowResolution) return false;
      if (ShadowBias != other.ShadowBias) return false;
      if (!object.Equals(ShadowColor, other.ShadowColor)) return false;
      if (PropertyCase != other.PropertyCase) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (LightName.Length != 0) hash ^= LightName.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Type) hash ^= Type.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Position) hash ^= Position.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Direction) hash ^= Direction.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Range) hash ^= Range.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Color) hash ^= Color.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Intensity) hash ^= Intensity.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.ConeAngle) hash ^= ConeAngle.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.PenumbraAngle) hash ^= PenumbraAngle.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Dropoff) hash ^= Dropoff.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.Shadows) hash ^= Shadows.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.ShadowResolution) hash ^= ShadowResolution.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.ShadowBias) hash ^= ShadowBias.GetHashCode();
      if (propertyCase_ == PropertyOneofCase.ShadowColor) hash ^= ShadowColor.GetHashCode();
      hash ^= (int) propertyCase_;
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (LightName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(LightName);
      }
      if (propertyCase_ == PropertyOneofCase.Type) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (propertyCase_ == PropertyOneofCase.Position) {
        output.WriteRawTag(26);
        output.WriteMessage(Position);
      }
      if (propertyCase_ == PropertyOneofCase.Direction) {
        output.WriteRawTag(34);
        output.WriteMessage(Direction);
      }
      if (propertyCase_ == PropertyOneofCase.Range) {
        output.WriteRawTag(45);
        output.WriteFloat(Range);
      }
      if (propertyCase_ == PropertyOneofCase.Color) {
        output.WriteRawTag(50);
        output.WriteMessage(Color);
      }
      if (propertyCase_ == PropertyOneofCase.Intensity) {
        output.WriteRawTag(61);
        output.WriteFloat(Intensity);
      }
      if (propertyCase_ == PropertyOneofCase.ConeAngle) {
        output.WriteRawTag(69);
        output.WriteFloat(ConeAngle);
      }
      if (propertyCase_ == PropertyOneofCase.PenumbraAngle) {
        output.WriteRawTag(77);
        output.WriteFloat(PenumbraAngle);
      }
      if (propertyCase_ == PropertyOneofCase.Dropoff) {
        output.WriteRawTag(85);
        output.WriteFloat(Dropoff);
      }
      if (propertyCase_ == PropertyOneofCase.Shadows) {
        output.WriteRawTag(88);
        output.WriteBool(Shadows);
      }
      if (propertyCase_ == PropertyOneofCase.ShadowResolution) {
        output.WriteRawTag(96);
        output.WriteInt32(ShadowResolution);
      }
      if (propertyCase_ == PropertyOneofCase.ShadowBias) {
        output.WriteRawTag(109);
        output.WriteFloat(ShadowBias);
      }
      if (propertyCase_ == PropertyOneofCase.ShadowColor) {
        output.WriteRawTag(114);
        output.WriteMessage(ShadowColor);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (LightName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LightName);
      }
      if (propertyCase_ == PropertyOneofCase.Type) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (propertyCase_ == PropertyOneofCase.Position) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Position);
      }
      if (propertyCase_ == PropertyOneofCase.Direction) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Direction);
      }
      if (propertyCase_ == PropertyOneofCase.Range) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.Color) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Color);
      }
      if (propertyCase_ == PropertyOneofCase.Intensity) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.ConeAngle) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.PenumbraAngle) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.Dropoff) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.Shadows) {
        size += 1 + 1;
      }
      if (propertyCase_ == PropertyOneofCase.ShadowResolution) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ShadowResolution);
      }
      if (propertyCase_ == PropertyOneofCase.ShadowBias) {
        size += 1 + 4;
      }
      if (propertyCase_ == PropertyOneofCase.ShadowColor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ShadowColor);
      }
      return size;
    }

    public void MergeFrom(LightChanged other) {
      if (other == null) {
        return;
      }
      if (other.LightName.Length != 0) {
        LightName = other.LightName;
      }
      switch (other.PropertyCase) {
        case PropertyOneofCase.Type:
          Type = other.Type;
          break;
        case PropertyOneofCase.Position:
          Position = other.Position;
          break;
        case PropertyOneofCase.Direction:
          Direction = other.Direction;
          break;
        case PropertyOneofCase.Range:
          Range = other.Range;
          break;
        case PropertyOneofCase.Color:
          Color = other.Color;
          break;
        case PropertyOneofCase.Intensity:
          Intensity = other.Intensity;
          break;
        case PropertyOneofCase.ConeAngle:
          ConeAngle = other.ConeAngle;
          break;
        case PropertyOneofCase.PenumbraAngle:
          PenumbraAngle = other.PenumbraAngle;
          break;
        case PropertyOneofCase.Dropoff:
          Dropoff = other.Dropoff;
          break;
        case PropertyOneofCase.Shadows:
          Shadows = other.Shadows;
          break;
        case PropertyOneofCase.ShadowResolution:
          ShadowResolution = other.ShadowResolution;
          break;
        case PropertyOneofCase.ShadowBias:
          ShadowBias = other.ShadowBias;
          break;
        case PropertyOneofCase.ShadowColor:
          ShadowColor = other.ShadowColor;
          break;
      }

    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            LightName = input.ReadString();
            break;
          }
          case 16: {
            property_ = input.ReadEnum();
            propertyCase_ = PropertyOneofCase.Type;
            break;
          }
          case 26: {
            global::Atom.Proto.Vector3 subBuilder = new global::Atom.Proto.Vector3();
            if (propertyCase_ == PropertyOneofCase.Position) {
              subBuilder.MergeFrom(Position);
            }
            input.ReadMessage(subBuilder);
            Position = subBuilder;
            break;
          }
          case 34: {
            global::Atom.Proto.Vector3 subBuilder = new global::Atom.Proto.Vector3();
            if (propertyCase_ == PropertyOneofCase.Direction) {
              subBuilder.MergeFrom(Direction);
            }
            input.ReadMessage(subBuilder);
            Direction = subBuilder;
            break;
          }
          case 45: {
            Range = input.ReadFloat();
            break;
          }
          case 50: {
            global::Atom.Proto.Color subBuilder = new global::Atom.Proto.Color();
            if (propertyCase_ == PropertyOneofCase.Color) {
              subBuilder.MergeFrom(Color);
            }
            input.ReadMessage(subBuilder);
            Color = subBuilder;
            break;
          }
          case 61: {
            Intensity = input.ReadFloat();
            break;
          }
          case 69: {
            ConeAngle = input.ReadFloat();
            break;
          }
          case 77: {
            PenumbraAngle = input.ReadFloat();
            break;
          }
          case 85: {
            Dropoff = input.ReadFloat();
            break;
          }
          case 88: {
            Shadows = input.ReadBool();
            break;
          }
          case 96: {
            ShadowResolution = input.ReadInt32();
            break;
          }
          case 109: {
            ShadowBias = input.ReadFloat();
            break;
          }
          case 114: {
            global::Atom.Proto.Color subBuilder = new global::Atom.Proto.Color();
            if (propertyCase_ == PropertyOneofCase.ShadowColor) {
              subBuilder.MergeFrom(ShadowColor);
            }
            input.ReadMessage(subBuilder);
            ShadowColor = subBuilder;
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
