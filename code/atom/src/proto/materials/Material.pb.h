// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: materials/Material.proto

#ifndef PROTOBUF_materials_2fMaterial_2eproto__INCLUDED
#define PROTOBUF_materials_2fMaterial_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "materials/MaterialType.pb.h"
#include "materials/Lambert.pb.h"
#include "materials/Phong.pb.h"
#include "materials/PhongE.pb.h"
#include "materials/Blinn.pb.h"
#include "materials/Anisotropic.pb.h"
// @@protoc_insertion_point(includes)

namespace atom {
namespace proto {
namespace materials {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_materials_2fMaterial_2eproto();
void protobuf_AssignDesc_materials_2fMaterial_2eproto();
void protobuf_ShutdownFile_materials_2fMaterial_2eproto();

class Material;

// ===================================================================

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  enum DataCase {
    kLambert = 3,
    kPhong = 4,
    kPhonge = 5,
    kBlinn = 6,
    kAnisotropic = 7,
    DATA_NOT_SET = 0,
  };

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  inline Material* New() const { return New(NULL); }

  Material* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Material* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .atom.proto.materials.MaterialType Type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::atom::proto::materials::MaterialType type() const;
  void set_type(::atom::proto::materials::MaterialType value);

  // optional .atom.proto.materials.Lambert Lambert = 3;
  bool has_lambert() const;
  void clear_lambert();
  static const int kLambertFieldNumber = 3;
  const ::atom::proto::materials::Lambert& lambert() const;
  ::atom::proto::materials::Lambert* mutable_lambert();
  ::atom::proto::materials::Lambert* release_lambert();
  void set_allocated_lambert(::atom::proto::materials::Lambert* lambert);

  // optional .atom.proto.materials.Phong Phong = 4;
  bool has_phong() const;
  void clear_phong();
  static const int kPhongFieldNumber = 4;
  const ::atom::proto::materials::Phong& phong() const;
  ::atom::proto::materials::Phong* mutable_phong();
  ::atom::proto::materials::Phong* release_phong();
  void set_allocated_phong(::atom::proto::materials::Phong* phong);

  // optional .atom.proto.materials.PhongE Phonge = 5;
  bool has_phonge() const;
  void clear_phonge();
  static const int kPhongeFieldNumber = 5;
  const ::atom::proto::materials::PhongE& phonge() const;
  ::atom::proto::materials::PhongE* mutable_phonge();
  ::atom::proto::materials::PhongE* release_phonge();
  void set_allocated_phonge(::atom::proto::materials::PhongE* phonge);

  // optional .atom.proto.materials.Blinn Blinn = 6;
  bool has_blinn() const;
  void clear_blinn();
  static const int kBlinnFieldNumber = 6;
  const ::atom::proto::materials::Blinn& blinn() const;
  ::atom::proto::materials::Blinn* mutable_blinn();
  ::atom::proto::materials::Blinn* release_blinn();
  void set_allocated_blinn(::atom::proto::materials::Blinn* blinn);

  // optional .atom.proto.materials.Anisotropic Anisotropic = 7;
  bool has_anisotropic() const;
  void clear_anisotropic();
  static const int kAnisotropicFieldNumber = 7;
  const ::atom::proto::materials::Anisotropic& anisotropic() const;
  ::atom::proto::materials::Anisotropic* mutable_anisotropic();
  ::atom::proto::materials::Anisotropic* release_anisotropic();
  void set_allocated_anisotropic(::atom::proto::materials::Anisotropic* anisotropic);

  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:atom.proto.materials.Material)
 private:
  inline void set_has_lambert();
  inline void set_has_phong();
  inline void set_has_phonge();
  inline void set_has_blinn();
  inline void set_has_anisotropic();

  inline bool has_Data() const;
  void clear_Data();
  inline void clear_has_Data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  union DataUnion {
    DataUnion() {}
    ::atom::proto::materials::Lambert* lambert_;
    ::atom::proto::materials::Phong* phong_;
    ::atom::proto::materials::PhongE* phonge_;
    ::atom::proto::materials::Blinn* blinn_;
    ::atom::proto::materials::Anisotropic* anisotropic_;
  } Data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_materials_2fMaterial_2eproto();
  friend void protobuf_AssignDesc_materials_2fMaterial_2eproto();
  friend void protobuf_ShutdownFile_materials_2fMaterial_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Material

// optional string Name = 1;
inline void Material::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atom.proto.materials.Material.Name)
}
inline void Material::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atom.proto.materials.Material.Name)
}
inline void Material::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atom.proto.materials.Material.Name)
}
inline ::std::string* Material::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Material::release_name() {
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Name)
}

// optional .atom.proto.materials.MaterialType Type = 2;
inline void Material::clear_type() {
  type_ = 0;
}
inline ::atom::proto::materials::MaterialType Material::type() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Type)
  return static_cast< ::atom::proto::materials::MaterialType >(type_);
}
inline void Material::set_type(::atom::proto::materials::MaterialType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:atom.proto.materials.Material.Type)
}

// optional .atom.proto.materials.Lambert Lambert = 3;
inline bool Material::has_lambert() const {
  return Data_case() == kLambert;
}
inline void Material::set_has_lambert() {
  _oneof_case_[0] = kLambert;
}
inline void Material::clear_lambert() {
  if (has_lambert()) {
    delete Data_.lambert_;
    clear_has_Data();
  }
}
inline  const ::atom::proto::materials::Lambert& Material::lambert() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Lambert)
  return has_lambert()
      ? *Data_.lambert_
      : ::atom::proto::materials::Lambert::default_instance();
}
inline ::atom::proto::materials::Lambert* Material::mutable_lambert() {
  if (!has_lambert()) {
    clear_Data();
    set_has_lambert();
    Data_.lambert_ = new ::atom::proto::materials::Lambert;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Lambert)
  return Data_.lambert_;
}
inline ::atom::proto::materials::Lambert* Material::release_lambert() {
  if (has_lambert()) {
    clear_has_Data();
    ::atom::proto::materials::Lambert* temp = Data_.lambert_;
    Data_.lambert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Material::set_allocated_lambert(::atom::proto::materials::Lambert* lambert) {
  clear_Data();
  if (lambert) {
    set_has_lambert();
    Data_.lambert_ = lambert;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Lambert)
}

// optional .atom.proto.materials.Phong Phong = 4;
inline bool Material::has_phong() const {
  return Data_case() == kPhong;
}
inline void Material::set_has_phong() {
  _oneof_case_[0] = kPhong;
}
inline void Material::clear_phong() {
  if (has_phong()) {
    delete Data_.phong_;
    clear_has_Data();
  }
}
inline  const ::atom::proto::materials::Phong& Material::phong() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Phong)
  return has_phong()
      ? *Data_.phong_
      : ::atom::proto::materials::Phong::default_instance();
}
inline ::atom::proto::materials::Phong* Material::mutable_phong() {
  if (!has_phong()) {
    clear_Data();
    set_has_phong();
    Data_.phong_ = new ::atom::proto::materials::Phong;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Phong)
  return Data_.phong_;
}
inline ::atom::proto::materials::Phong* Material::release_phong() {
  if (has_phong()) {
    clear_has_Data();
    ::atom::proto::materials::Phong* temp = Data_.phong_;
    Data_.phong_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Material::set_allocated_phong(::atom::proto::materials::Phong* phong) {
  clear_Data();
  if (phong) {
    set_has_phong();
    Data_.phong_ = phong;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Phong)
}

// optional .atom.proto.materials.PhongE Phonge = 5;
inline bool Material::has_phonge() const {
  return Data_case() == kPhonge;
}
inline void Material::set_has_phonge() {
  _oneof_case_[0] = kPhonge;
}
inline void Material::clear_phonge() {
  if (has_phonge()) {
    delete Data_.phonge_;
    clear_has_Data();
  }
}
inline  const ::atom::proto::materials::PhongE& Material::phonge() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Phonge)
  return has_phonge()
      ? *Data_.phonge_
      : ::atom::proto::materials::PhongE::default_instance();
}
inline ::atom::proto::materials::PhongE* Material::mutable_phonge() {
  if (!has_phonge()) {
    clear_Data();
    set_has_phonge();
    Data_.phonge_ = new ::atom::proto::materials::PhongE;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Phonge)
  return Data_.phonge_;
}
inline ::atom::proto::materials::PhongE* Material::release_phonge() {
  if (has_phonge()) {
    clear_has_Data();
    ::atom::proto::materials::PhongE* temp = Data_.phonge_;
    Data_.phonge_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Material::set_allocated_phonge(::atom::proto::materials::PhongE* phonge) {
  clear_Data();
  if (phonge) {
    set_has_phonge();
    Data_.phonge_ = phonge;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Phonge)
}

// optional .atom.proto.materials.Blinn Blinn = 6;
inline bool Material::has_blinn() const {
  return Data_case() == kBlinn;
}
inline void Material::set_has_blinn() {
  _oneof_case_[0] = kBlinn;
}
inline void Material::clear_blinn() {
  if (has_blinn()) {
    delete Data_.blinn_;
    clear_has_Data();
  }
}
inline  const ::atom::proto::materials::Blinn& Material::blinn() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Blinn)
  return has_blinn()
      ? *Data_.blinn_
      : ::atom::proto::materials::Blinn::default_instance();
}
inline ::atom::proto::materials::Blinn* Material::mutable_blinn() {
  if (!has_blinn()) {
    clear_Data();
    set_has_blinn();
    Data_.blinn_ = new ::atom::proto::materials::Blinn;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Blinn)
  return Data_.blinn_;
}
inline ::atom::proto::materials::Blinn* Material::release_blinn() {
  if (has_blinn()) {
    clear_has_Data();
    ::atom::proto::materials::Blinn* temp = Data_.blinn_;
    Data_.blinn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Material::set_allocated_blinn(::atom::proto::materials::Blinn* blinn) {
  clear_Data();
  if (blinn) {
    set_has_blinn();
    Data_.blinn_ = blinn;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Blinn)
}

// optional .atom.proto.materials.Anisotropic Anisotropic = 7;
inline bool Material::has_anisotropic() const {
  return Data_case() == kAnisotropic;
}
inline void Material::set_has_anisotropic() {
  _oneof_case_[0] = kAnisotropic;
}
inline void Material::clear_anisotropic() {
  if (has_anisotropic()) {
    delete Data_.anisotropic_;
    clear_has_Data();
  }
}
inline  const ::atom::proto::materials::Anisotropic& Material::anisotropic() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Material.Anisotropic)
  return has_anisotropic()
      ? *Data_.anisotropic_
      : ::atom::proto::materials::Anisotropic::default_instance();
}
inline ::atom::proto::materials::Anisotropic* Material::mutable_anisotropic() {
  if (!has_anisotropic()) {
    clear_Data();
    set_has_anisotropic();
    Data_.anisotropic_ = new ::atom::proto::materials::Anisotropic;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Material.Anisotropic)
  return Data_.anisotropic_;
}
inline ::atom::proto::materials::Anisotropic* Material::release_anisotropic() {
  if (has_anisotropic()) {
    clear_has_Data();
    ::atom::proto::materials::Anisotropic* temp = Data_.anisotropic_;
    Data_.anisotropic_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Material::set_allocated_anisotropic(::atom::proto::materials::Anisotropic* anisotropic) {
  clear_Data();
  if (anisotropic) {
    set_has_anisotropic();
    Data_.anisotropic_ = anisotropic;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Material.Anisotropic)
}

inline bool Material::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void Material::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Material::DataCase Material::Data_case() const {
  return Material::DataCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace materials
}  // namespace proto
}  // namespace atom

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_materials_2fMaterial_2eproto__INCLUDED
