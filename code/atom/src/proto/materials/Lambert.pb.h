// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: materials/Lambert.proto

#ifndef PROTOBUF_materials_2fLambert_2eproto__INCLUDED
#define PROTOBUF_materials_2fLambert_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "materials/TexturedParameter.pb.h"
// @@protoc_insertion_point(includes)

namespace atom {
namespace proto {
namespace materials {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_materials_2fLambert_2eproto();
void protobuf_AssignDesc_materials_2fLambert_2eproto();
void protobuf_ShutdownFile_materials_2fLambert_2eproto();

class Lambert;

// ===================================================================

class Lambert : public ::google::protobuf::Message {
 public:
  Lambert();
  virtual ~Lambert();

  Lambert(const Lambert& from);

  inline Lambert& operator=(const Lambert& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lambert& default_instance();

  void Swap(Lambert* other);

  // implements Message ----------------------------------------------

  inline Lambert* New() const { return New(NULL); }

  Lambert* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lambert& from);
  void MergeFrom(const Lambert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lambert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .atom.proto.materials.TexturedParameter Color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  const ::atom::proto::materials::TexturedParameter& color() const;
  ::atom::proto::materials::TexturedParameter* mutable_color();
  ::atom::proto::materials::TexturedParameter* release_color();
  void set_allocated_color(::atom::proto::materials::TexturedParameter* color);

  // optional .atom.proto.materials.TexturedParameter Transparency = 2;
  bool has_transparency() const;
  void clear_transparency();
  static const int kTransparencyFieldNumber = 2;
  const ::atom::proto::materials::TexturedParameter& transparency() const;
  ::atom::proto::materials::TexturedParameter* mutable_transparency();
  ::atom::proto::materials::TexturedParameter* release_transparency();
  void set_allocated_transparency(::atom::proto::materials::TexturedParameter* transparency);

  // optional .atom.proto.materials.TexturedParameter AmbientColor = 3;
  bool has_ambientcolor() const;
  void clear_ambientcolor();
  static const int kAmbientColorFieldNumber = 3;
  const ::atom::proto::materials::TexturedParameter& ambientcolor() const;
  ::atom::proto::materials::TexturedParameter* mutable_ambientcolor();
  ::atom::proto::materials::TexturedParameter* release_ambientcolor();
  void set_allocated_ambientcolor(::atom::proto::materials::TexturedParameter* ambientcolor);

  // optional .atom.proto.materials.TexturedParameter Incandescence = 4;
  bool has_incandescence() const;
  void clear_incandescence();
  static const int kIncandescenceFieldNumber = 4;
  const ::atom::proto::materials::TexturedParameter& incandescence() const;
  ::atom::proto::materials::TexturedParameter* mutable_incandescence();
  ::atom::proto::materials::TexturedParameter* release_incandescence();
  void set_allocated_incandescence(::atom::proto::materials::TexturedParameter* incandescence);

  // optional string BumpMap = 5;
  void clear_bumpmap();
  static const int kBumpMapFieldNumber = 5;
  const ::std::string& bumpmap() const;
  void set_bumpmap(const ::std::string& value);
  void set_bumpmap(const char* value);
  void set_bumpmap(const char* value, size_t size);
  ::std::string* mutable_bumpmap();
  ::std::string* release_bumpmap();
  void set_allocated_bumpmap(::std::string* bumpmap);

  // optional .atom.proto.materials.TexturedParameter DiffuseAmount = 6;
  bool has_diffuseamount() const;
  void clear_diffuseamount();
  static const int kDiffuseAmountFieldNumber = 6;
  const ::atom::proto::materials::TexturedParameter& diffuseamount() const;
  ::atom::proto::materials::TexturedParameter* mutable_diffuseamount();
  ::atom::proto::materials::TexturedParameter* release_diffuseamount();
  void set_allocated_diffuseamount(::atom::proto::materials::TexturedParameter* diffuseamount);

  // optional .atom.proto.materials.TexturedParameter Translucence = 7;
  bool has_translucence() const;
  void clear_translucence();
  static const int kTranslucenceFieldNumber = 7;
  const ::atom::proto::materials::TexturedParameter& translucence() const;
  ::atom::proto::materials::TexturedParameter* mutable_translucence();
  ::atom::proto::materials::TexturedParameter* release_translucence();
  void set_allocated_translucence(::atom::proto::materials::TexturedParameter* translucence);

  // optional .atom.proto.materials.TexturedParameter TranslucenceDepth = 8;
  bool has_translucencedepth() const;
  void clear_translucencedepth();
  static const int kTranslucenceDepthFieldNumber = 8;
  const ::atom::proto::materials::TexturedParameter& translucencedepth() const;
  ::atom::proto::materials::TexturedParameter* mutable_translucencedepth();
  ::atom::proto::materials::TexturedParameter* release_translucencedepth();
  void set_allocated_translucencedepth(::atom::proto::materials::TexturedParameter* translucencedepth);

  // optional .atom.proto.materials.TexturedParameter TranslucenceFocus = 9;
  bool has_translucencefocus() const;
  void clear_translucencefocus();
  static const int kTranslucenceFocusFieldNumber = 9;
  const ::atom::proto::materials::TexturedParameter& translucencefocus() const;
  ::atom::proto::materials::TexturedParameter* mutable_translucencefocus();
  ::atom::proto::materials::TexturedParameter* release_translucencefocus();
  void set_allocated_translucencefocus(::atom::proto::materials::TexturedParameter* translucencefocus);

  // optional .atom.proto.materials.TexturedParameter GlowIntensity = 10;
  bool has_glowintensity() const;
  void clear_glowintensity();
  static const int kGlowIntensityFieldNumber = 10;
  const ::atom::proto::materials::TexturedParameter& glowintensity() const;
  ::atom::proto::materials::TexturedParameter* mutable_glowintensity();
  ::atom::proto::materials::TexturedParameter* release_glowintensity();
  void set_allocated_glowintensity(::atom::proto::materials::TexturedParameter* glowintensity);

  // @@protoc_insertion_point(class_scope:atom.proto.materials.Lambert)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::atom::proto::materials::TexturedParameter* color_;
  ::atom::proto::materials::TexturedParameter* transparency_;
  ::atom::proto::materials::TexturedParameter* ambientcolor_;
  ::atom::proto::materials::TexturedParameter* incandescence_;
  ::google::protobuf::internal::ArenaStringPtr bumpmap_;
  ::atom::proto::materials::TexturedParameter* diffuseamount_;
  ::atom::proto::materials::TexturedParameter* translucence_;
  ::atom::proto::materials::TexturedParameter* translucencedepth_;
  ::atom::proto::materials::TexturedParameter* translucencefocus_;
  ::atom::proto::materials::TexturedParameter* glowintensity_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_materials_2fLambert_2eproto();
  friend void protobuf_AssignDesc_materials_2fLambert_2eproto();
  friend void protobuf_ShutdownFile_materials_2fLambert_2eproto();

  void InitAsDefaultInstance();
  static Lambert* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Lambert

// optional .atom.proto.materials.TexturedParameter Color = 1;
inline bool Lambert::has_color() const {
  return !_is_default_instance_ && color_ != NULL;
}
inline void Lambert::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) delete color_;
  color_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::color() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.Color)
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.Color)
  return color_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_color() {
  
  ::atom::proto::materials::TexturedParameter* temp = color_;
  color_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_color(::atom::proto::materials::TexturedParameter* color) {
  delete color_;
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.Color)
}

// optional .atom.proto.materials.TexturedParameter Transparency = 2;
inline bool Lambert::has_transparency() const {
  return !_is_default_instance_ && transparency_ != NULL;
}
inline void Lambert::clear_transparency() {
  if (GetArenaNoVirtual() == NULL && transparency_ != NULL) delete transparency_;
  transparency_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::transparency() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.Transparency)
  return transparency_ != NULL ? *transparency_ : *default_instance_->transparency_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_transparency() {
  
  if (transparency_ == NULL) {
    transparency_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.Transparency)
  return transparency_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_transparency() {
  
  ::atom::proto::materials::TexturedParameter* temp = transparency_;
  transparency_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_transparency(::atom::proto::materials::TexturedParameter* transparency) {
  delete transparency_;
  transparency_ = transparency;
  if (transparency) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.Transparency)
}

// optional .atom.proto.materials.TexturedParameter AmbientColor = 3;
inline bool Lambert::has_ambientcolor() const {
  return !_is_default_instance_ && ambientcolor_ != NULL;
}
inline void Lambert::clear_ambientcolor() {
  if (GetArenaNoVirtual() == NULL && ambientcolor_ != NULL) delete ambientcolor_;
  ambientcolor_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::ambientcolor() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.AmbientColor)
  return ambientcolor_ != NULL ? *ambientcolor_ : *default_instance_->ambientcolor_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_ambientcolor() {
  
  if (ambientcolor_ == NULL) {
    ambientcolor_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.AmbientColor)
  return ambientcolor_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_ambientcolor() {
  
  ::atom::proto::materials::TexturedParameter* temp = ambientcolor_;
  ambientcolor_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_ambientcolor(::atom::proto::materials::TexturedParameter* ambientcolor) {
  delete ambientcolor_;
  ambientcolor_ = ambientcolor;
  if (ambientcolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.AmbientColor)
}

// optional .atom.proto.materials.TexturedParameter Incandescence = 4;
inline bool Lambert::has_incandescence() const {
  return !_is_default_instance_ && incandescence_ != NULL;
}
inline void Lambert::clear_incandescence() {
  if (GetArenaNoVirtual() == NULL && incandescence_ != NULL) delete incandescence_;
  incandescence_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::incandescence() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.Incandescence)
  return incandescence_ != NULL ? *incandescence_ : *default_instance_->incandescence_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_incandescence() {
  
  if (incandescence_ == NULL) {
    incandescence_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.Incandescence)
  return incandescence_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_incandescence() {
  
  ::atom::proto::materials::TexturedParameter* temp = incandescence_;
  incandescence_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_incandescence(::atom::proto::materials::TexturedParameter* incandescence) {
  delete incandescence_;
  incandescence_ = incandescence;
  if (incandescence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.Incandescence)
}

// optional string BumpMap = 5;
inline void Lambert::clear_bumpmap() {
  bumpmap_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Lambert::bumpmap() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.BumpMap)
  return bumpmap_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lambert::set_bumpmap(const ::std::string& value) {
  
  bumpmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atom.proto.materials.Lambert.BumpMap)
}
inline void Lambert::set_bumpmap(const char* value) {
  
  bumpmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atom.proto.materials.Lambert.BumpMap)
}
inline void Lambert::set_bumpmap(const char* value, size_t size) {
  
  bumpmap_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atom.proto.materials.Lambert.BumpMap)
}
inline ::std::string* Lambert::mutable_bumpmap() {
  
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.BumpMap)
  return bumpmap_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Lambert::release_bumpmap() {
  
  return bumpmap_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lambert::set_allocated_bumpmap(::std::string* bumpmap) {
  if (bumpmap != NULL) {
    
  } else {
    
  }
  bumpmap_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bumpmap);
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.BumpMap)
}

// optional .atom.proto.materials.TexturedParameter DiffuseAmount = 6;
inline bool Lambert::has_diffuseamount() const {
  return !_is_default_instance_ && diffuseamount_ != NULL;
}
inline void Lambert::clear_diffuseamount() {
  if (GetArenaNoVirtual() == NULL && diffuseamount_ != NULL) delete diffuseamount_;
  diffuseamount_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::diffuseamount() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.DiffuseAmount)
  return diffuseamount_ != NULL ? *diffuseamount_ : *default_instance_->diffuseamount_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_diffuseamount() {
  
  if (diffuseamount_ == NULL) {
    diffuseamount_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.DiffuseAmount)
  return diffuseamount_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_diffuseamount() {
  
  ::atom::proto::materials::TexturedParameter* temp = diffuseamount_;
  diffuseamount_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_diffuseamount(::atom::proto::materials::TexturedParameter* diffuseamount) {
  delete diffuseamount_;
  diffuseamount_ = diffuseamount;
  if (diffuseamount) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.DiffuseAmount)
}

// optional .atom.proto.materials.TexturedParameter Translucence = 7;
inline bool Lambert::has_translucence() const {
  return !_is_default_instance_ && translucence_ != NULL;
}
inline void Lambert::clear_translucence() {
  if (GetArenaNoVirtual() == NULL && translucence_ != NULL) delete translucence_;
  translucence_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::translucence() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.Translucence)
  return translucence_ != NULL ? *translucence_ : *default_instance_->translucence_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_translucence() {
  
  if (translucence_ == NULL) {
    translucence_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.Translucence)
  return translucence_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_translucence() {
  
  ::atom::proto::materials::TexturedParameter* temp = translucence_;
  translucence_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_translucence(::atom::proto::materials::TexturedParameter* translucence) {
  delete translucence_;
  translucence_ = translucence;
  if (translucence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.Translucence)
}

// optional .atom.proto.materials.TexturedParameter TranslucenceDepth = 8;
inline bool Lambert::has_translucencedepth() const {
  return !_is_default_instance_ && translucencedepth_ != NULL;
}
inline void Lambert::clear_translucencedepth() {
  if (GetArenaNoVirtual() == NULL && translucencedepth_ != NULL) delete translucencedepth_;
  translucencedepth_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::translucencedepth() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.TranslucenceDepth)
  return translucencedepth_ != NULL ? *translucencedepth_ : *default_instance_->translucencedepth_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_translucencedepth() {
  
  if (translucencedepth_ == NULL) {
    translucencedepth_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.TranslucenceDepth)
  return translucencedepth_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_translucencedepth() {
  
  ::atom::proto::materials::TexturedParameter* temp = translucencedepth_;
  translucencedepth_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_translucencedepth(::atom::proto::materials::TexturedParameter* translucencedepth) {
  delete translucencedepth_;
  translucencedepth_ = translucencedepth;
  if (translucencedepth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.TranslucenceDepth)
}

// optional .atom.proto.materials.TexturedParameter TranslucenceFocus = 9;
inline bool Lambert::has_translucencefocus() const {
  return !_is_default_instance_ && translucencefocus_ != NULL;
}
inline void Lambert::clear_translucencefocus() {
  if (GetArenaNoVirtual() == NULL && translucencefocus_ != NULL) delete translucencefocus_;
  translucencefocus_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::translucencefocus() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.TranslucenceFocus)
  return translucencefocus_ != NULL ? *translucencefocus_ : *default_instance_->translucencefocus_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_translucencefocus() {
  
  if (translucencefocus_ == NULL) {
    translucencefocus_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.TranslucenceFocus)
  return translucencefocus_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_translucencefocus() {
  
  ::atom::proto::materials::TexturedParameter* temp = translucencefocus_;
  translucencefocus_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_translucencefocus(::atom::proto::materials::TexturedParameter* translucencefocus) {
  delete translucencefocus_;
  translucencefocus_ = translucencefocus;
  if (translucencefocus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.TranslucenceFocus)
}

// optional .atom.proto.materials.TexturedParameter GlowIntensity = 10;
inline bool Lambert::has_glowintensity() const {
  return !_is_default_instance_ && glowintensity_ != NULL;
}
inline void Lambert::clear_glowintensity() {
  if (GetArenaNoVirtual() == NULL && glowintensity_ != NULL) delete glowintensity_;
  glowintensity_ = NULL;
}
inline const ::atom::proto::materials::TexturedParameter& Lambert::glowintensity() const {
  // @@protoc_insertion_point(field_get:atom.proto.materials.Lambert.GlowIntensity)
  return glowintensity_ != NULL ? *glowintensity_ : *default_instance_->glowintensity_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::mutable_glowintensity() {
  
  if (glowintensity_ == NULL) {
    glowintensity_ = new ::atom::proto::materials::TexturedParameter;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.materials.Lambert.GlowIntensity)
  return glowintensity_;
}
inline ::atom::proto::materials::TexturedParameter* Lambert::release_glowintensity() {
  
  ::atom::proto::materials::TexturedParameter* temp = glowintensity_;
  glowintensity_ = NULL;
  return temp;
}
inline void Lambert::set_allocated_glowintensity(::atom::proto::materials::TexturedParameter* glowintensity) {
  delete glowintensity_;
  glowintensity_ = glowintensity;
  if (glowintensity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.materials.Lambert.GlowIntensity)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace materials
}  // namespace proto
}  // namespace atom

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_materials_2fLambert_2eproto__INCLUDED
