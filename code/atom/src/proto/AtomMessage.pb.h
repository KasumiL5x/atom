// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AtomMessage.proto

#ifndef PROTOBUF_AtomMessage_2eproto__INCLUDED
#define PROTOBUF_AtomMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Scene.pb.h"
#include "meshes/Mesh.pb.h"
#include "meshes/MeshPointsChanged.pb.h"
#include "meshes/MeshGeometryChanged.pb.h"
#include "meshes/MeshMaterialChanged.pb.h"
#include "Camera.pb.h"
#include "lights/Light.pb.h"
#include "lights/LightChanged.pb.h"
#include "materials/Material.pb.h"
#include "materials/MaterialChanged.pb.h"
#include "materials/Texture.pb.h"
#include "materials/TextureChanged.pb.h"
#include "NameChanged.pb.h"
#include "Transform.pb.h"
#include "Annotation.pb.h"
#include "Curve.pb.h"
#include "MatrixChanged.pb.h"
#include "VisibilityChanged.pb.h"
// @@protoc_insertion_point(includes)

namespace atom {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_AtomMessage_2eproto();
void protobuf_AssignDesc_AtomMessage_2eproto();
void protobuf_ShutdownFile_AtomMessage_2eproto();

class AtomMessage;

// ===================================================================

class AtomMessage : public ::google::protobuf::Message {
 public:
  AtomMessage();
  virtual ~AtomMessage();

  AtomMessage(const AtomMessage& from);

  inline AtomMessage& operator=(const AtomMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AtomMessage& default_instance();

  enum MsgCase {
    kDebugMessage = 1,
    kScene = 2,
    kMesh = 3,
    kMeshPointsChanged = 4,
    kMeshGeometryChanged = 5,
    kMeshMaterialChanged = 6,
    kCamera = 7,
    kLight = 8,
    kLightChanged = 9,
    kMaterial = 10,
    kMaterialChanged = 11,
    kTexture = 12,
    kTextureChanged = 13,
    kNameChanged = 14,
    kTransform = 15,
    kAnnotation = 16,
    kCurve = 17,
    kMatrixChanged = 18,
    kVisibilityChanged = 19,
    MSG_NOT_SET = 0,
  };

  void Swap(AtomMessage* other);

  // implements Message ----------------------------------------------

  inline AtomMessage* New() const { return New(NULL); }

  AtomMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AtomMessage& from);
  void MergeFrom(const AtomMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AtomMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DebugMessage = 1;
  private:
  bool has_debugmessage() const;
  public:
  void clear_debugmessage();
  static const int kDebugMessageFieldNumber = 1;
  const ::std::string& debugmessage() const;
  void set_debugmessage(const ::std::string& value);
  void set_debugmessage(const char* value);
  void set_debugmessage(const char* value, size_t size);
  ::std::string* mutable_debugmessage();
  ::std::string* release_debugmessage();
  void set_allocated_debugmessage(::std::string* debugmessage);

  // optional .atom.proto.Scene Scene = 2;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 2;
  const ::atom::proto::Scene& scene() const;
  ::atom::proto::Scene* mutable_scene();
  ::atom::proto::Scene* release_scene();
  void set_allocated_scene(::atom::proto::Scene* scene);

  // optional .atom.proto.meshes.Mesh Mesh = 3;
  bool has_mesh() const;
  void clear_mesh();
  static const int kMeshFieldNumber = 3;
  const ::atom::proto::meshes::Mesh& mesh() const;
  ::atom::proto::meshes::Mesh* mutable_mesh();
  ::atom::proto::meshes::Mesh* release_mesh();
  void set_allocated_mesh(::atom::proto::meshes::Mesh* mesh);

  // optional .atom.proto.meshes.MeshPointsChanged MeshPointsChanged = 4;
  bool has_meshpointschanged() const;
  void clear_meshpointschanged();
  static const int kMeshPointsChangedFieldNumber = 4;
  const ::atom::proto::meshes::MeshPointsChanged& meshpointschanged() const;
  ::atom::proto::meshes::MeshPointsChanged* mutable_meshpointschanged();
  ::atom::proto::meshes::MeshPointsChanged* release_meshpointschanged();
  void set_allocated_meshpointschanged(::atom::proto::meshes::MeshPointsChanged* meshpointschanged);

  // optional .atom.proto.meshes.MeshGeometryChanged MeshGeometryChanged = 5;
  bool has_meshgeometrychanged() const;
  void clear_meshgeometrychanged();
  static const int kMeshGeometryChangedFieldNumber = 5;
  const ::atom::proto::meshes::MeshGeometryChanged& meshgeometrychanged() const;
  ::atom::proto::meshes::MeshGeometryChanged* mutable_meshgeometrychanged();
  ::atom::proto::meshes::MeshGeometryChanged* release_meshgeometrychanged();
  void set_allocated_meshgeometrychanged(::atom::proto::meshes::MeshGeometryChanged* meshgeometrychanged);

  // optional .atom.proto.meshes.MeshMaterialChanged MeshMaterialChanged = 6;
  bool has_meshmaterialchanged() const;
  void clear_meshmaterialchanged();
  static const int kMeshMaterialChangedFieldNumber = 6;
  const ::atom::proto::meshes::MeshMaterialChanged& meshmaterialchanged() const;
  ::atom::proto::meshes::MeshMaterialChanged* mutable_meshmaterialchanged();
  ::atom::proto::meshes::MeshMaterialChanged* release_meshmaterialchanged();
  void set_allocated_meshmaterialchanged(::atom::proto::meshes::MeshMaterialChanged* meshmaterialchanged);

  // optional .atom.proto.Camera Camera = 7;
  bool has_camera() const;
  void clear_camera();
  static const int kCameraFieldNumber = 7;
  const ::atom::proto::Camera& camera() const;
  ::atom::proto::Camera* mutable_camera();
  ::atom::proto::Camera* release_camera();
  void set_allocated_camera(::atom::proto::Camera* camera);

  // optional .atom.proto.lights.Light Light = 8;
  bool has_light() const;
  void clear_light();
  static const int kLightFieldNumber = 8;
  const ::atom::proto::lights::Light& light() const;
  ::atom::proto::lights::Light* mutable_light();
  ::atom::proto::lights::Light* release_light();
  void set_allocated_light(::atom::proto::lights::Light* light);

  // optional .atom.proto.lights.LightChanged LightChanged = 9;
  bool has_lightchanged() const;
  void clear_lightchanged();
  static const int kLightChangedFieldNumber = 9;
  const ::atom::proto::lights::LightChanged& lightchanged() const;
  ::atom::proto::lights::LightChanged* mutable_lightchanged();
  ::atom::proto::lights::LightChanged* release_lightchanged();
  void set_allocated_lightchanged(::atom::proto::lights::LightChanged* lightchanged);

  // optional .atom.proto.materials.Material Material = 10;
  bool has_material() const;
  void clear_material();
  static const int kMaterialFieldNumber = 10;
  const ::atom::proto::materials::Material& material() const;
  ::atom::proto::materials::Material* mutable_material();
  ::atom::proto::materials::Material* release_material();
  void set_allocated_material(::atom::proto::materials::Material* material);

  // optional .atom.proto.materials.MaterialChanged MaterialChanged = 11;
  bool has_materialchanged() const;
  void clear_materialchanged();
  static const int kMaterialChangedFieldNumber = 11;
  const ::atom::proto::materials::MaterialChanged& materialchanged() const;
  ::atom::proto::materials::MaterialChanged* mutable_materialchanged();
  ::atom::proto::materials::MaterialChanged* release_materialchanged();
  void set_allocated_materialchanged(::atom::proto::materials::MaterialChanged* materialchanged);

  // optional .atom.proto.materials.Texture Texture = 12;
  bool has_texture() const;
  void clear_texture();
  static const int kTextureFieldNumber = 12;
  const ::atom::proto::materials::Texture& texture() const;
  ::atom::proto::materials::Texture* mutable_texture();
  ::atom::proto::materials::Texture* release_texture();
  void set_allocated_texture(::atom::proto::materials::Texture* texture);

  // optional .atom.proto.materials.TextureChanged TextureChanged = 13;
  bool has_texturechanged() const;
  void clear_texturechanged();
  static const int kTextureChangedFieldNumber = 13;
  const ::atom::proto::materials::TextureChanged& texturechanged() const;
  ::atom::proto::materials::TextureChanged* mutable_texturechanged();
  ::atom::proto::materials::TextureChanged* release_texturechanged();
  void set_allocated_texturechanged(::atom::proto::materials::TextureChanged* texturechanged);

  // optional .atom.proto.NameChanged NameChanged = 14;
  bool has_namechanged() const;
  void clear_namechanged();
  static const int kNameChangedFieldNumber = 14;
  const ::atom::proto::NameChanged& namechanged() const;
  ::atom::proto::NameChanged* mutable_namechanged();
  ::atom::proto::NameChanged* release_namechanged();
  void set_allocated_namechanged(::atom::proto::NameChanged* namechanged);

  // optional .atom.proto.Transform Transform = 15;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 15;
  const ::atom::proto::Transform& transform() const;
  ::atom::proto::Transform* mutable_transform();
  ::atom::proto::Transform* release_transform();
  void set_allocated_transform(::atom::proto::Transform* transform);

  // optional .atom.proto.Annotation Annotation = 16;
  bool has_annotation() const;
  void clear_annotation();
  static const int kAnnotationFieldNumber = 16;
  const ::atom::proto::Annotation& annotation() const;
  ::atom::proto::Annotation* mutable_annotation();
  ::atom::proto::Annotation* release_annotation();
  void set_allocated_annotation(::atom::proto::Annotation* annotation);

  // optional .atom.proto.Curve Curve = 17;
  bool has_curve() const;
  void clear_curve();
  static const int kCurveFieldNumber = 17;
  const ::atom::proto::Curve& curve() const;
  ::atom::proto::Curve* mutable_curve();
  ::atom::proto::Curve* release_curve();
  void set_allocated_curve(::atom::proto::Curve* curve);

  // optional .atom.proto.MatrixChanged MatrixChanged = 18;
  bool has_matrixchanged() const;
  void clear_matrixchanged();
  static const int kMatrixChangedFieldNumber = 18;
  const ::atom::proto::MatrixChanged& matrixchanged() const;
  ::atom::proto::MatrixChanged* mutable_matrixchanged();
  ::atom::proto::MatrixChanged* release_matrixchanged();
  void set_allocated_matrixchanged(::atom::proto::MatrixChanged* matrixchanged);

  // optional .atom.proto.VisibilityChanged VisibilityChanged = 19;
  bool has_visibilitychanged() const;
  void clear_visibilitychanged();
  static const int kVisibilityChangedFieldNumber = 19;
  const ::atom::proto::VisibilityChanged& visibilitychanged() const;
  ::atom::proto::VisibilityChanged* mutable_visibilitychanged();
  ::atom::proto::VisibilityChanged* release_visibilitychanged();
  void set_allocated_visibilitychanged(::atom::proto::VisibilityChanged* visibilitychanged);

  MsgCase Msg_case() const;
  // @@protoc_insertion_point(class_scope:atom.proto.AtomMessage)
 private:
  inline void set_has_debugmessage();
  inline void set_has_scene();
  inline void set_has_mesh();
  inline void set_has_meshpointschanged();
  inline void set_has_meshgeometrychanged();
  inline void set_has_meshmaterialchanged();
  inline void set_has_camera();
  inline void set_has_light();
  inline void set_has_lightchanged();
  inline void set_has_material();
  inline void set_has_materialchanged();
  inline void set_has_texture();
  inline void set_has_texturechanged();
  inline void set_has_namechanged();
  inline void set_has_transform();
  inline void set_has_annotation();
  inline void set_has_curve();
  inline void set_has_matrixchanged();
  inline void set_has_visibilitychanged();

  inline bool has_Msg() const;
  void clear_Msg();
  inline void clear_has_Msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union MsgUnion {
    MsgUnion() {}
    ::google::protobuf::internal::ArenaStringPtr debugmessage_;
    ::atom::proto::Scene* scene_;
    ::atom::proto::meshes::Mesh* mesh_;
    ::atom::proto::meshes::MeshPointsChanged* meshpointschanged_;
    ::atom::proto::meshes::MeshGeometryChanged* meshgeometrychanged_;
    ::atom::proto::meshes::MeshMaterialChanged* meshmaterialchanged_;
    ::atom::proto::Camera* camera_;
    ::atom::proto::lights::Light* light_;
    ::atom::proto::lights::LightChanged* lightchanged_;
    ::atom::proto::materials::Material* material_;
    ::atom::proto::materials::MaterialChanged* materialchanged_;
    ::atom::proto::materials::Texture* texture_;
    ::atom::proto::materials::TextureChanged* texturechanged_;
    ::atom::proto::NameChanged* namechanged_;
    ::atom::proto::Transform* transform_;
    ::atom::proto::Annotation* annotation_;
    ::atom::proto::Curve* curve_;
    ::atom::proto::MatrixChanged* matrixchanged_;
    ::atom::proto::VisibilityChanged* visibilitychanged_;
  } Msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_AtomMessage_2eproto();
  friend void protobuf_AssignDesc_AtomMessage_2eproto();
  friend void protobuf_ShutdownFile_AtomMessage_2eproto();

  void InitAsDefaultInstance();
  static AtomMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AtomMessage

// optional string DebugMessage = 1;
inline bool AtomMessage::has_debugmessage() const {
  return Msg_case() == kDebugMessage;
}
inline void AtomMessage::set_has_debugmessage() {
  _oneof_case_[0] = kDebugMessage;
}
inline void AtomMessage::clear_debugmessage() {
  if (has_debugmessage()) {
    Msg_.debugmessage_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_Msg();
  }
}
inline const ::std::string& AtomMessage::debugmessage() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.DebugMessage)
  if (has_debugmessage()) {
    return Msg_.debugmessage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AtomMessage::set_debugmessage(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:atom.proto.AtomMessage.DebugMessage)
  if (!has_debugmessage()) {
    clear_Msg();
    set_has_debugmessage();
    Msg_.debugmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Msg_.debugmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:atom.proto.AtomMessage.DebugMessage)
}
inline void AtomMessage::set_debugmessage(const char* value) {
  if (!has_debugmessage()) {
    clear_Msg();
    set_has_debugmessage();
    Msg_.debugmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Msg_.debugmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:atom.proto.AtomMessage.DebugMessage)
}
inline void AtomMessage::set_debugmessage(const char* value, size_t size) {
  if (!has_debugmessage()) {
    clear_Msg();
    set_has_debugmessage();
    Msg_.debugmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  Msg_.debugmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:atom.proto.AtomMessage.DebugMessage)
}
inline ::std::string* AtomMessage::mutable_debugmessage() {
  if (!has_debugmessage()) {
    clear_Msg();
    set_has_debugmessage();
    Msg_.debugmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.DebugMessage)
  return Msg_.debugmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AtomMessage::release_debugmessage() {
  if (has_debugmessage()) {
    clear_has_Msg();
    return Msg_.debugmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_debugmessage(::std::string* debugmessage) {
  if (!has_debugmessage()) {
    Msg_.debugmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_Msg();
  if (debugmessage != NULL) {
    set_has_debugmessage();
    Msg_.debugmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        debugmessage);
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.DebugMessage)
}

// optional .atom.proto.Scene Scene = 2;
inline bool AtomMessage::has_scene() const {
  return Msg_case() == kScene;
}
inline void AtomMessage::set_has_scene() {
  _oneof_case_[0] = kScene;
}
inline void AtomMessage::clear_scene() {
  if (has_scene()) {
    delete Msg_.scene_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::Scene& AtomMessage::scene() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Scene)
  return has_scene()
      ? *Msg_.scene_
      : ::atom::proto::Scene::default_instance();
}
inline ::atom::proto::Scene* AtomMessage::mutable_scene() {
  if (!has_scene()) {
    clear_Msg();
    set_has_scene();
    Msg_.scene_ = new ::atom::proto::Scene;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Scene)
  return Msg_.scene_;
}
inline ::atom::proto::Scene* AtomMessage::release_scene() {
  if (has_scene()) {
    clear_has_Msg();
    ::atom::proto::Scene* temp = Msg_.scene_;
    Msg_.scene_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_scene(::atom::proto::Scene* scene) {
  clear_Msg();
  if (scene) {
    set_has_scene();
    Msg_.scene_ = scene;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Scene)
}

// optional .atom.proto.meshes.Mesh Mesh = 3;
inline bool AtomMessage::has_mesh() const {
  return Msg_case() == kMesh;
}
inline void AtomMessage::set_has_mesh() {
  _oneof_case_[0] = kMesh;
}
inline void AtomMessage::clear_mesh() {
  if (has_mesh()) {
    delete Msg_.mesh_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::meshes::Mesh& AtomMessage::mesh() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Mesh)
  return has_mesh()
      ? *Msg_.mesh_
      : ::atom::proto::meshes::Mesh::default_instance();
}
inline ::atom::proto::meshes::Mesh* AtomMessage::mutable_mesh() {
  if (!has_mesh()) {
    clear_Msg();
    set_has_mesh();
    Msg_.mesh_ = new ::atom::proto::meshes::Mesh;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Mesh)
  return Msg_.mesh_;
}
inline ::atom::proto::meshes::Mesh* AtomMessage::release_mesh() {
  if (has_mesh()) {
    clear_has_Msg();
    ::atom::proto::meshes::Mesh* temp = Msg_.mesh_;
    Msg_.mesh_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_mesh(::atom::proto::meshes::Mesh* mesh) {
  clear_Msg();
  if (mesh) {
    set_has_mesh();
    Msg_.mesh_ = mesh;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Mesh)
}

// optional .atom.proto.meshes.MeshPointsChanged MeshPointsChanged = 4;
inline bool AtomMessage::has_meshpointschanged() const {
  return Msg_case() == kMeshPointsChanged;
}
inline void AtomMessage::set_has_meshpointschanged() {
  _oneof_case_[0] = kMeshPointsChanged;
}
inline void AtomMessage::clear_meshpointschanged() {
  if (has_meshpointschanged()) {
    delete Msg_.meshpointschanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::meshes::MeshPointsChanged& AtomMessage::meshpointschanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.MeshPointsChanged)
  return has_meshpointschanged()
      ? *Msg_.meshpointschanged_
      : ::atom::proto::meshes::MeshPointsChanged::default_instance();
}
inline ::atom::proto::meshes::MeshPointsChanged* AtomMessage::mutable_meshpointschanged() {
  if (!has_meshpointschanged()) {
    clear_Msg();
    set_has_meshpointschanged();
    Msg_.meshpointschanged_ = new ::atom::proto::meshes::MeshPointsChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.MeshPointsChanged)
  return Msg_.meshpointschanged_;
}
inline ::atom::proto::meshes::MeshPointsChanged* AtomMessage::release_meshpointschanged() {
  if (has_meshpointschanged()) {
    clear_has_Msg();
    ::atom::proto::meshes::MeshPointsChanged* temp = Msg_.meshpointschanged_;
    Msg_.meshpointschanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_meshpointschanged(::atom::proto::meshes::MeshPointsChanged* meshpointschanged) {
  clear_Msg();
  if (meshpointschanged) {
    set_has_meshpointschanged();
    Msg_.meshpointschanged_ = meshpointschanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.MeshPointsChanged)
}

// optional .atom.proto.meshes.MeshGeometryChanged MeshGeometryChanged = 5;
inline bool AtomMessage::has_meshgeometrychanged() const {
  return Msg_case() == kMeshGeometryChanged;
}
inline void AtomMessage::set_has_meshgeometrychanged() {
  _oneof_case_[0] = kMeshGeometryChanged;
}
inline void AtomMessage::clear_meshgeometrychanged() {
  if (has_meshgeometrychanged()) {
    delete Msg_.meshgeometrychanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::meshes::MeshGeometryChanged& AtomMessage::meshgeometrychanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.MeshGeometryChanged)
  return has_meshgeometrychanged()
      ? *Msg_.meshgeometrychanged_
      : ::atom::proto::meshes::MeshGeometryChanged::default_instance();
}
inline ::atom::proto::meshes::MeshGeometryChanged* AtomMessage::mutable_meshgeometrychanged() {
  if (!has_meshgeometrychanged()) {
    clear_Msg();
    set_has_meshgeometrychanged();
    Msg_.meshgeometrychanged_ = new ::atom::proto::meshes::MeshGeometryChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.MeshGeometryChanged)
  return Msg_.meshgeometrychanged_;
}
inline ::atom::proto::meshes::MeshGeometryChanged* AtomMessage::release_meshgeometrychanged() {
  if (has_meshgeometrychanged()) {
    clear_has_Msg();
    ::atom::proto::meshes::MeshGeometryChanged* temp = Msg_.meshgeometrychanged_;
    Msg_.meshgeometrychanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_meshgeometrychanged(::atom::proto::meshes::MeshGeometryChanged* meshgeometrychanged) {
  clear_Msg();
  if (meshgeometrychanged) {
    set_has_meshgeometrychanged();
    Msg_.meshgeometrychanged_ = meshgeometrychanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.MeshGeometryChanged)
}

// optional .atom.proto.meshes.MeshMaterialChanged MeshMaterialChanged = 6;
inline bool AtomMessage::has_meshmaterialchanged() const {
  return Msg_case() == kMeshMaterialChanged;
}
inline void AtomMessage::set_has_meshmaterialchanged() {
  _oneof_case_[0] = kMeshMaterialChanged;
}
inline void AtomMessage::clear_meshmaterialchanged() {
  if (has_meshmaterialchanged()) {
    delete Msg_.meshmaterialchanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::meshes::MeshMaterialChanged& AtomMessage::meshmaterialchanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.MeshMaterialChanged)
  return has_meshmaterialchanged()
      ? *Msg_.meshmaterialchanged_
      : ::atom::proto::meshes::MeshMaterialChanged::default_instance();
}
inline ::atom::proto::meshes::MeshMaterialChanged* AtomMessage::mutable_meshmaterialchanged() {
  if (!has_meshmaterialchanged()) {
    clear_Msg();
    set_has_meshmaterialchanged();
    Msg_.meshmaterialchanged_ = new ::atom::proto::meshes::MeshMaterialChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.MeshMaterialChanged)
  return Msg_.meshmaterialchanged_;
}
inline ::atom::proto::meshes::MeshMaterialChanged* AtomMessage::release_meshmaterialchanged() {
  if (has_meshmaterialchanged()) {
    clear_has_Msg();
    ::atom::proto::meshes::MeshMaterialChanged* temp = Msg_.meshmaterialchanged_;
    Msg_.meshmaterialchanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_meshmaterialchanged(::atom::proto::meshes::MeshMaterialChanged* meshmaterialchanged) {
  clear_Msg();
  if (meshmaterialchanged) {
    set_has_meshmaterialchanged();
    Msg_.meshmaterialchanged_ = meshmaterialchanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.MeshMaterialChanged)
}

// optional .atom.proto.Camera Camera = 7;
inline bool AtomMessage::has_camera() const {
  return Msg_case() == kCamera;
}
inline void AtomMessage::set_has_camera() {
  _oneof_case_[0] = kCamera;
}
inline void AtomMessage::clear_camera() {
  if (has_camera()) {
    delete Msg_.camera_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::Camera& AtomMessage::camera() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Camera)
  return has_camera()
      ? *Msg_.camera_
      : ::atom::proto::Camera::default_instance();
}
inline ::atom::proto::Camera* AtomMessage::mutable_camera() {
  if (!has_camera()) {
    clear_Msg();
    set_has_camera();
    Msg_.camera_ = new ::atom::proto::Camera;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Camera)
  return Msg_.camera_;
}
inline ::atom::proto::Camera* AtomMessage::release_camera() {
  if (has_camera()) {
    clear_has_Msg();
    ::atom::proto::Camera* temp = Msg_.camera_;
    Msg_.camera_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_camera(::atom::proto::Camera* camera) {
  clear_Msg();
  if (camera) {
    set_has_camera();
    Msg_.camera_ = camera;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Camera)
}

// optional .atom.proto.lights.Light Light = 8;
inline bool AtomMessage::has_light() const {
  return Msg_case() == kLight;
}
inline void AtomMessage::set_has_light() {
  _oneof_case_[0] = kLight;
}
inline void AtomMessage::clear_light() {
  if (has_light()) {
    delete Msg_.light_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::lights::Light& AtomMessage::light() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Light)
  return has_light()
      ? *Msg_.light_
      : ::atom::proto::lights::Light::default_instance();
}
inline ::atom::proto::lights::Light* AtomMessage::mutable_light() {
  if (!has_light()) {
    clear_Msg();
    set_has_light();
    Msg_.light_ = new ::atom::proto::lights::Light;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Light)
  return Msg_.light_;
}
inline ::atom::proto::lights::Light* AtomMessage::release_light() {
  if (has_light()) {
    clear_has_Msg();
    ::atom::proto::lights::Light* temp = Msg_.light_;
    Msg_.light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_light(::atom::proto::lights::Light* light) {
  clear_Msg();
  if (light) {
    set_has_light();
    Msg_.light_ = light;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Light)
}

// optional .atom.proto.lights.LightChanged LightChanged = 9;
inline bool AtomMessage::has_lightchanged() const {
  return Msg_case() == kLightChanged;
}
inline void AtomMessage::set_has_lightchanged() {
  _oneof_case_[0] = kLightChanged;
}
inline void AtomMessage::clear_lightchanged() {
  if (has_lightchanged()) {
    delete Msg_.lightchanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::lights::LightChanged& AtomMessage::lightchanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.LightChanged)
  return has_lightchanged()
      ? *Msg_.lightchanged_
      : ::atom::proto::lights::LightChanged::default_instance();
}
inline ::atom::proto::lights::LightChanged* AtomMessage::mutable_lightchanged() {
  if (!has_lightchanged()) {
    clear_Msg();
    set_has_lightchanged();
    Msg_.lightchanged_ = new ::atom::proto::lights::LightChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.LightChanged)
  return Msg_.lightchanged_;
}
inline ::atom::proto::lights::LightChanged* AtomMessage::release_lightchanged() {
  if (has_lightchanged()) {
    clear_has_Msg();
    ::atom::proto::lights::LightChanged* temp = Msg_.lightchanged_;
    Msg_.lightchanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_lightchanged(::atom::proto::lights::LightChanged* lightchanged) {
  clear_Msg();
  if (lightchanged) {
    set_has_lightchanged();
    Msg_.lightchanged_ = lightchanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.LightChanged)
}

// optional .atom.proto.materials.Material Material = 10;
inline bool AtomMessage::has_material() const {
  return Msg_case() == kMaterial;
}
inline void AtomMessage::set_has_material() {
  _oneof_case_[0] = kMaterial;
}
inline void AtomMessage::clear_material() {
  if (has_material()) {
    delete Msg_.material_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::materials::Material& AtomMessage::material() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Material)
  return has_material()
      ? *Msg_.material_
      : ::atom::proto::materials::Material::default_instance();
}
inline ::atom::proto::materials::Material* AtomMessage::mutable_material() {
  if (!has_material()) {
    clear_Msg();
    set_has_material();
    Msg_.material_ = new ::atom::proto::materials::Material;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Material)
  return Msg_.material_;
}
inline ::atom::proto::materials::Material* AtomMessage::release_material() {
  if (has_material()) {
    clear_has_Msg();
    ::atom::proto::materials::Material* temp = Msg_.material_;
    Msg_.material_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_material(::atom::proto::materials::Material* material) {
  clear_Msg();
  if (material) {
    set_has_material();
    Msg_.material_ = material;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Material)
}

// optional .atom.proto.materials.MaterialChanged MaterialChanged = 11;
inline bool AtomMessage::has_materialchanged() const {
  return Msg_case() == kMaterialChanged;
}
inline void AtomMessage::set_has_materialchanged() {
  _oneof_case_[0] = kMaterialChanged;
}
inline void AtomMessage::clear_materialchanged() {
  if (has_materialchanged()) {
    delete Msg_.materialchanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::materials::MaterialChanged& AtomMessage::materialchanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.MaterialChanged)
  return has_materialchanged()
      ? *Msg_.materialchanged_
      : ::atom::proto::materials::MaterialChanged::default_instance();
}
inline ::atom::proto::materials::MaterialChanged* AtomMessage::mutable_materialchanged() {
  if (!has_materialchanged()) {
    clear_Msg();
    set_has_materialchanged();
    Msg_.materialchanged_ = new ::atom::proto::materials::MaterialChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.MaterialChanged)
  return Msg_.materialchanged_;
}
inline ::atom::proto::materials::MaterialChanged* AtomMessage::release_materialchanged() {
  if (has_materialchanged()) {
    clear_has_Msg();
    ::atom::proto::materials::MaterialChanged* temp = Msg_.materialchanged_;
    Msg_.materialchanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_materialchanged(::atom::proto::materials::MaterialChanged* materialchanged) {
  clear_Msg();
  if (materialchanged) {
    set_has_materialchanged();
    Msg_.materialchanged_ = materialchanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.MaterialChanged)
}

// optional .atom.proto.materials.Texture Texture = 12;
inline bool AtomMessage::has_texture() const {
  return Msg_case() == kTexture;
}
inline void AtomMessage::set_has_texture() {
  _oneof_case_[0] = kTexture;
}
inline void AtomMessage::clear_texture() {
  if (has_texture()) {
    delete Msg_.texture_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::materials::Texture& AtomMessage::texture() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Texture)
  return has_texture()
      ? *Msg_.texture_
      : ::atom::proto::materials::Texture::default_instance();
}
inline ::atom::proto::materials::Texture* AtomMessage::mutable_texture() {
  if (!has_texture()) {
    clear_Msg();
    set_has_texture();
    Msg_.texture_ = new ::atom::proto::materials::Texture;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Texture)
  return Msg_.texture_;
}
inline ::atom::proto::materials::Texture* AtomMessage::release_texture() {
  if (has_texture()) {
    clear_has_Msg();
    ::atom::proto::materials::Texture* temp = Msg_.texture_;
    Msg_.texture_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_texture(::atom::proto::materials::Texture* texture) {
  clear_Msg();
  if (texture) {
    set_has_texture();
    Msg_.texture_ = texture;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Texture)
}

// optional .atom.proto.materials.TextureChanged TextureChanged = 13;
inline bool AtomMessage::has_texturechanged() const {
  return Msg_case() == kTextureChanged;
}
inline void AtomMessage::set_has_texturechanged() {
  _oneof_case_[0] = kTextureChanged;
}
inline void AtomMessage::clear_texturechanged() {
  if (has_texturechanged()) {
    delete Msg_.texturechanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::materials::TextureChanged& AtomMessage::texturechanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.TextureChanged)
  return has_texturechanged()
      ? *Msg_.texturechanged_
      : ::atom::proto::materials::TextureChanged::default_instance();
}
inline ::atom::proto::materials::TextureChanged* AtomMessage::mutable_texturechanged() {
  if (!has_texturechanged()) {
    clear_Msg();
    set_has_texturechanged();
    Msg_.texturechanged_ = new ::atom::proto::materials::TextureChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.TextureChanged)
  return Msg_.texturechanged_;
}
inline ::atom::proto::materials::TextureChanged* AtomMessage::release_texturechanged() {
  if (has_texturechanged()) {
    clear_has_Msg();
    ::atom::proto::materials::TextureChanged* temp = Msg_.texturechanged_;
    Msg_.texturechanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_texturechanged(::atom::proto::materials::TextureChanged* texturechanged) {
  clear_Msg();
  if (texturechanged) {
    set_has_texturechanged();
    Msg_.texturechanged_ = texturechanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.TextureChanged)
}

// optional .atom.proto.NameChanged NameChanged = 14;
inline bool AtomMessage::has_namechanged() const {
  return Msg_case() == kNameChanged;
}
inline void AtomMessage::set_has_namechanged() {
  _oneof_case_[0] = kNameChanged;
}
inline void AtomMessage::clear_namechanged() {
  if (has_namechanged()) {
    delete Msg_.namechanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::NameChanged& AtomMessage::namechanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.NameChanged)
  return has_namechanged()
      ? *Msg_.namechanged_
      : ::atom::proto::NameChanged::default_instance();
}
inline ::atom::proto::NameChanged* AtomMessage::mutable_namechanged() {
  if (!has_namechanged()) {
    clear_Msg();
    set_has_namechanged();
    Msg_.namechanged_ = new ::atom::proto::NameChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.NameChanged)
  return Msg_.namechanged_;
}
inline ::atom::proto::NameChanged* AtomMessage::release_namechanged() {
  if (has_namechanged()) {
    clear_has_Msg();
    ::atom::proto::NameChanged* temp = Msg_.namechanged_;
    Msg_.namechanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_namechanged(::atom::proto::NameChanged* namechanged) {
  clear_Msg();
  if (namechanged) {
    set_has_namechanged();
    Msg_.namechanged_ = namechanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.NameChanged)
}

// optional .atom.proto.Transform Transform = 15;
inline bool AtomMessage::has_transform() const {
  return Msg_case() == kTransform;
}
inline void AtomMessage::set_has_transform() {
  _oneof_case_[0] = kTransform;
}
inline void AtomMessage::clear_transform() {
  if (has_transform()) {
    delete Msg_.transform_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::Transform& AtomMessage::transform() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Transform)
  return has_transform()
      ? *Msg_.transform_
      : ::atom::proto::Transform::default_instance();
}
inline ::atom::proto::Transform* AtomMessage::mutable_transform() {
  if (!has_transform()) {
    clear_Msg();
    set_has_transform();
    Msg_.transform_ = new ::atom::proto::Transform;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Transform)
  return Msg_.transform_;
}
inline ::atom::proto::Transform* AtomMessage::release_transform() {
  if (has_transform()) {
    clear_has_Msg();
    ::atom::proto::Transform* temp = Msg_.transform_;
    Msg_.transform_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_transform(::atom::proto::Transform* transform) {
  clear_Msg();
  if (transform) {
    set_has_transform();
    Msg_.transform_ = transform;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Transform)
}

// optional .atom.proto.Annotation Annotation = 16;
inline bool AtomMessage::has_annotation() const {
  return Msg_case() == kAnnotation;
}
inline void AtomMessage::set_has_annotation() {
  _oneof_case_[0] = kAnnotation;
}
inline void AtomMessage::clear_annotation() {
  if (has_annotation()) {
    delete Msg_.annotation_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::Annotation& AtomMessage::annotation() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Annotation)
  return has_annotation()
      ? *Msg_.annotation_
      : ::atom::proto::Annotation::default_instance();
}
inline ::atom::proto::Annotation* AtomMessage::mutable_annotation() {
  if (!has_annotation()) {
    clear_Msg();
    set_has_annotation();
    Msg_.annotation_ = new ::atom::proto::Annotation;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Annotation)
  return Msg_.annotation_;
}
inline ::atom::proto::Annotation* AtomMessage::release_annotation() {
  if (has_annotation()) {
    clear_has_Msg();
    ::atom::proto::Annotation* temp = Msg_.annotation_;
    Msg_.annotation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_annotation(::atom::proto::Annotation* annotation) {
  clear_Msg();
  if (annotation) {
    set_has_annotation();
    Msg_.annotation_ = annotation;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Annotation)
}

// optional .atom.proto.Curve Curve = 17;
inline bool AtomMessage::has_curve() const {
  return Msg_case() == kCurve;
}
inline void AtomMessage::set_has_curve() {
  _oneof_case_[0] = kCurve;
}
inline void AtomMessage::clear_curve() {
  if (has_curve()) {
    delete Msg_.curve_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::Curve& AtomMessage::curve() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.Curve)
  return has_curve()
      ? *Msg_.curve_
      : ::atom::proto::Curve::default_instance();
}
inline ::atom::proto::Curve* AtomMessage::mutable_curve() {
  if (!has_curve()) {
    clear_Msg();
    set_has_curve();
    Msg_.curve_ = new ::atom::proto::Curve;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.Curve)
  return Msg_.curve_;
}
inline ::atom::proto::Curve* AtomMessage::release_curve() {
  if (has_curve()) {
    clear_has_Msg();
    ::atom::proto::Curve* temp = Msg_.curve_;
    Msg_.curve_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_curve(::atom::proto::Curve* curve) {
  clear_Msg();
  if (curve) {
    set_has_curve();
    Msg_.curve_ = curve;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.Curve)
}

// optional .atom.proto.MatrixChanged MatrixChanged = 18;
inline bool AtomMessage::has_matrixchanged() const {
  return Msg_case() == kMatrixChanged;
}
inline void AtomMessage::set_has_matrixchanged() {
  _oneof_case_[0] = kMatrixChanged;
}
inline void AtomMessage::clear_matrixchanged() {
  if (has_matrixchanged()) {
    delete Msg_.matrixchanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::MatrixChanged& AtomMessage::matrixchanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.MatrixChanged)
  return has_matrixchanged()
      ? *Msg_.matrixchanged_
      : ::atom::proto::MatrixChanged::default_instance();
}
inline ::atom::proto::MatrixChanged* AtomMessage::mutable_matrixchanged() {
  if (!has_matrixchanged()) {
    clear_Msg();
    set_has_matrixchanged();
    Msg_.matrixchanged_ = new ::atom::proto::MatrixChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.MatrixChanged)
  return Msg_.matrixchanged_;
}
inline ::atom::proto::MatrixChanged* AtomMessage::release_matrixchanged() {
  if (has_matrixchanged()) {
    clear_has_Msg();
    ::atom::proto::MatrixChanged* temp = Msg_.matrixchanged_;
    Msg_.matrixchanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_matrixchanged(::atom::proto::MatrixChanged* matrixchanged) {
  clear_Msg();
  if (matrixchanged) {
    set_has_matrixchanged();
    Msg_.matrixchanged_ = matrixchanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.MatrixChanged)
}

// optional .atom.proto.VisibilityChanged VisibilityChanged = 19;
inline bool AtomMessage::has_visibilitychanged() const {
  return Msg_case() == kVisibilityChanged;
}
inline void AtomMessage::set_has_visibilitychanged() {
  _oneof_case_[0] = kVisibilityChanged;
}
inline void AtomMessage::clear_visibilitychanged() {
  if (has_visibilitychanged()) {
    delete Msg_.visibilitychanged_;
    clear_has_Msg();
  }
}
inline  const ::atom::proto::VisibilityChanged& AtomMessage::visibilitychanged() const {
  // @@protoc_insertion_point(field_get:atom.proto.AtomMessage.VisibilityChanged)
  return has_visibilitychanged()
      ? *Msg_.visibilitychanged_
      : ::atom::proto::VisibilityChanged::default_instance();
}
inline ::atom::proto::VisibilityChanged* AtomMessage::mutable_visibilitychanged() {
  if (!has_visibilitychanged()) {
    clear_Msg();
    set_has_visibilitychanged();
    Msg_.visibilitychanged_ = new ::atom::proto::VisibilityChanged;
  }
  // @@protoc_insertion_point(field_mutable:atom.proto.AtomMessage.VisibilityChanged)
  return Msg_.visibilitychanged_;
}
inline ::atom::proto::VisibilityChanged* AtomMessage::release_visibilitychanged() {
  if (has_visibilitychanged()) {
    clear_has_Msg();
    ::atom::proto::VisibilityChanged* temp = Msg_.visibilitychanged_;
    Msg_.visibilitychanged_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AtomMessage::set_allocated_visibilitychanged(::atom::proto::VisibilityChanged* visibilitychanged) {
  clear_Msg();
  if (visibilitychanged) {
    set_has_visibilitychanged();
    Msg_.visibilitychanged_ = visibilitychanged;
  }
  // @@protoc_insertion_point(field_set_allocated:atom.proto.AtomMessage.VisibilityChanged)
}

inline bool AtomMessage::has_Msg() const {
  return Msg_case() != MSG_NOT_SET;
}
inline void AtomMessage::clear_has_Msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline AtomMessage::MsgCase AtomMessage::Msg_case() const {
  return AtomMessage::MsgCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace atom

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AtomMessage_2eproto__INCLUDED
